{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/Users/xavesenduk/Documents/Project/Blockchain Sederhana/savjeecoin-frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/Users/xavesenduk/Documents/Project/Blockchain Sederhana/savjeecoin-frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/xavesenduk/Documents/Project/Blockchain Sederhana/savjeecoin-frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar SHA256 = require('crypto-js/sha256');\n\nvar EC = require('elliptic').ec;\n\nvar ec = new EC('secp256k1');\n\nvar Transaction = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * @param {string} fromAddress\n   * @param {string} toAddress\n   * @param {number} amount\n   */\n  function Transaction(fromAddress, toAddress, amount) {\n    _classCallCheck(this, Transaction);\n\n    this.fromAddress = fromAddress;\n    this.toAddress = toAddress;\n    this.amount = amount;\n    this.timestamp = Date.now();\n  }\n  /**\n   * Creates a SHA256 hash of the transaction\n   *\n   * @returns {string}\n   */\n\n\n  _createClass(Transaction, [{\n    key: \"calculateHash\",\n    value: function calculateHash() {\n      return SHA256(this.fromAddress + this.toAddress + this.amount + this.timestamp).toString();\n    }\n    /**\n     * Signs a transaction with the given signingKey (which is an Elliptic keypair\n     * object that contains a private key). The signature is then stored inside the\n     * transaction object and later stored on the blockchain.\n     *\n     * @param {string} signingKey\n     */\n\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(signingKey) {\n      // You can only send a transaction from the wallet that is linked to your\n      // key. So here we check if the fromAddress matches your publicKey\n      if (signingKey.getPublic('hex') !== this.fromAddress) {\n        throw new Error('You cannot sign transactions for other wallets!');\n      } // Calculate the hash of this transaction, sign it with the key\n      // and store it inside the transaction obect\n\n\n      var hashTx = this.calculateHash();\n      var sig = signingKey.sign(hashTx, 'base64');\n      this.signature = sig.toDER('hex');\n    }\n    /**\n     * Checks if the signature is valid (transaction has not been tampered with).\n     * It uses the fromAddress as the public key.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      // If the transaction doesn't have a from address we assume it's a\n      // mining reward and that it's valid. You could verify this in a\n      // different way (special field for instance)\n      if (this.fromAddress === null) return true;\n\n      if (!this.signature || this.signature.length === 0) {\n        throw new Error('No signature in this transaction');\n      }\n\n      var publicKey = ec.keyFromPublic(this.fromAddress, 'hex');\n      return publicKey.verify(this.calculateHash(), this.signature);\n    }\n  }]);\n\n  return Transaction;\n}();\n\nvar Block = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * @param {number} timestamp\n   * @param {Transaction[]} transactions\n   * @param {string} previousHash\n   */\n  function Block(timestamp, transactions) {\n    var previousHash = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n    _classCallCheck(this, Block);\n\n    this.previousHash = previousHash;\n    this.timestamp = timestamp;\n    this.transactions = transactions;\n    this.nonce = 0;\n    this.hash = this.calculateHash();\n  }\n  /**\n   * Returns the SHA256 of this block (by processing all the data stored\n   * inside this block)\n   *\n   * @returns {string}\n   */\n\n\n  _createClass(Block, [{\n    key: \"calculateHash\",\n    value: function calculateHash() {\n      return SHA256(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce).toString();\n    }\n    /**\n     * Starts the mining process on the block. It changes the 'nonce' until the hash\n     * of the block starts with enough zeros (= difficulty)\n     *\n     * @param {number} difficulty\n     */\n\n  }, {\n    key: \"mineBlock\",\n    value: function mineBlock(difficulty) {\n      while (this.hash.substring(0, difficulty) !== Array(difficulty + 1).join('0')) {\n        this.nonce++;\n        this.hash = this.calculateHash();\n      }\n\n      console.log(\"Block mined: \".concat(this.hash));\n    }\n    /**\n     * Validates all the transactions inside this block (signature + hash) and\n     * returns true if everything checks out. False if the block is invalid.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasValidTransactions\",\n    value: function hasValidTransactions() {\n      var _iterator = _createForOfIteratorHelper(this.transactions),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var tx = _step.value;\n\n          if (!tx.isValid()) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n  }]);\n\n  return Block;\n}();\n\nvar Blockchain = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Blockchain() {\n    _classCallCheck(this, Blockchain);\n\n    this.chain = [this.createGenesisBlock()];\n    this.difficulty = 2;\n    this.pendingTransactions = [];\n    this.miningReward = 100;\n  }\n  /**\n   * @returns {Block}\n   */\n\n\n  _createClass(Blockchain, [{\n    key: \"createGenesisBlock\",\n    value: function createGenesisBlock() {\n      return new Block(Date.parse('2017-01-01'), [], '0');\n    }\n    /**\n     * Returns the latest block on our chain. Useful when you want to create a\n     * new Block and you need the hash of the previous Block.\n     *\n     * @returns {Block[]}\n     */\n\n  }, {\n    key: \"getLatestBlock\",\n    value: function getLatestBlock() {\n      return this.chain[this.chain.length - 1];\n    }\n    /**\n     * Takes all the pending transactions, puts them in a Block and starts the\n     * mining process. It also adds a transaction to send the mining reward to\n     * the given address.\n     *\n     * @param {string} miningRewardAddress\n     */\n\n  }, {\n    key: \"minePendingTransactions\",\n    value: function minePendingTransactions(miningRewardAddress) {\n      var rewardTx = new Transaction(null, miningRewardAddress, this.miningReward);\n      this.pendingTransactions.push(rewardTx);\n      var block = new Block(Date.now(), this.pendingTransactions, this.getLatestBlock().hash);\n      block.mineBlock(this.difficulty);\n      console.log('Block successfully mined!');\n      this.chain.push(block);\n      this.pendingTransactions = [];\n    }\n    /**\n     * Add a new transaction to the list of pending transactions (to be added\n     * next time the mining process starts). This verifies that the given\n     * transaction is properly signed.\n     *\n     * @param {Transaction} transaction\n     */\n\n  }, {\n    key: \"addTransaction\",\n    value: function addTransaction(transaction) {\n      if (!transaction.fromAddress || !transaction.toAddress) {\n        throw new Error('Transaction must include from and to address');\n      } // Verify the transactiion\n\n\n      if (!transaction.isValid()) {\n        throw new Error('Cannot add invalid transaction to chain');\n      }\n\n      if (transaction.amount <= 0) {\n        throw new Error('Transaction amount should be higher than 0');\n      }\n\n      this.pendingTransactions.push(transaction);\n    }\n    /**\n     * Returns the balance of a given wallet address.\n     *\n     * @param {string} address\n     * @returns {number} The balance of the wallet\n     */\n\n  }, {\n    key: \"getBalanceOfAddress\",\n    value: function getBalanceOfAddress(address) {\n      var balance = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(this.chain),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var block = _step2.value;\n\n          var _iterator3 = _createForOfIteratorHelper(block.transactions),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var trans = _step3.value;\n\n              if (trans.fromAddress === address) {\n                balance -= trans.amount;\n              }\n\n              if (trans.toAddress === address) {\n                balance += trans.amount;\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return balance;\n    }\n    /**\n     * Returns a list of all transactions that happened\n     * to and from the given wallet address.\n     *\n     * @param  {string} address\n     * @return {Transaction[]}\n     */\n\n  }, {\n    key: \"getAllTransactionsForWallet\",\n    value: function getAllTransactionsForWallet(address) {\n      var txs = [];\n\n      var _iterator4 = _createForOfIteratorHelper(this.chain),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var block = _step4.value;\n\n          var _iterator5 = _createForOfIteratorHelper(block.transactions),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var tx = _step5.value;\n\n              if (tx.fromAddress === address || tx.toAddress === address) {\n                txs.push(tx);\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return txs;\n    }\n    /**\n     * Loops over all the blocks in the chain and verify if they are properly\n     * linked together and nobody has tampered with the hashes. By checking\n     * the blocks it also verifies the (signed) transactions inside of them.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isChainValid\",\n    value: function isChainValid() {\n      // Check if the Genesis block hasn't been tampered with by comparing\n      // the output of createGenesisBlock with the first block on our chain\n      var realGenesis = JSON.stringify(this.createGenesisBlock());\n\n      if (realGenesis !== JSON.stringify(this.chain[0])) {\n        return false;\n      } // Check the remaining blocks on the chain to see if there hashes and\n      // signatures are correct\n\n\n      for (var i = 1; i < this.chain.length; i++) {\n        var currentBlock = this.chain[i];\n\n        if (!currentBlock.hasValidTransactions()) {\n          return false;\n        }\n\n        if (currentBlock.hash !== currentBlock.calculateHash()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return Blockchain;\n}();\n\nmodule.exports.Blockchain = Blockchain;\nmodule.exports.Block = Block;\nmodule.exports.Transaction = Transaction;","map":null,"metadata":{},"sourceType":"script"}